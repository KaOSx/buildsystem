#!/bin/bash -e
#
#   makepkg - make packages compatable for use with pacman
#   @configure_input@
#
#   Copyright (c) 2006-2009 Pacman Development Team <pacman-dev@archlinux.org>
#   Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
#   Copyright (c) 2005 by Aurelien Foret <orelien@chez.com>
#   Copyright (c) 2006 by Miklos Vajna <vmiklos@frugalware.org>
#   Copyright (c) 2005 by Christian Hamar <krics@linuxforum.hu>
#   Copyright (c) 2006 by Alex Smith <alex@alex-smith.me.uk>
#   Copyright (c) 2006 by Andras Voroskoi <voroskoi@frugalware.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# makepkg uses quite a few external programs during its execution. You
# need to have at least the following installed for makepkg to function:
#   awk, bsdtar (libarchive), bzip2, coreutils, fakeroot, find (findutils),
#   getopt (util-linux), gettext, grep, gzip, openssl, sed

# gettext initialization
export TEXTDOMAIN='pacman'
export TEXTDOMAINDIR='/usr/share/locale'

# file -i does not work on Mac OSX unless legacy mode is set
export COMMAND_MODE='legacy'

myver='3.3-kdemod'
confdir='../_buildscripts'
BUILDSCRIPT='PKGBUILD'
startdir="$PWD"
ARCH="$_arch"
current_repo=`pushd $startdir &>/dev/null; pushd .. &>/dev/null; pwd | awk -F '/' '{print $NF}'; popd &>/dev/null; popd &>/dev/null`
srcdir="$startdir/src"
pkgdir="$startdir/pkg"
dbgdir="$startdir/dbg"
hdrdir="$startdir/hdr"

packaging_options=('strip' 'splitdbg' 'splithdr' 'docs' 'libtool' 'emptydirs' 'zipman' 'purge')
other_options=('ccache' 'distcc' 'makeflags' 'force')
splitpkg_overrides=('pkgdesc' 'license' 'groups' 'depends' 'optdepends' 'provides' \
                    'conflicts' 'replaces' 'backup' 'options' 'install')
readonly -a packaging_options other_options splitpkg_overrides

# Options
ASROOT=0
CLEANUP=0
CLEANCACHE=0
DEP_BIN=0
FORCE=0
INFAKEROOT=0
GENINTEG=0
INSTALL=0
NOBUILD=0
NODEPS=0
NOEXTRACT=0
RMDEPS=0
REPKG=0
LOGGING=0
SOURCEONLY=0
IGNOREARCH=0
HOLDVER=0
PKGFUNC=0
SPLITPKG=0
COLORMSG=0

# Forces the pkgver of the current PKGBUILD. Used by the fakeroot call
# when dealing with svn/cvs/etc PKGBUILDs.
FORCE_VER=""

PACMAN_OPTS=

### SUBROUTINES ###

plain() {
	local mesg=$1; shift
	if [ $COLORMSG -eq 1 ]; then
		printf "\033[1;1m    ${mesg}\033[1;0m\n" "$@" >&2
	else
		printf "    ${mesg}\n" "$@" >&2
	fi
}

msg() {
	local mesg=$1; shift
	if [ $COLORMSG -eq 1 ]; then
		printf "\033[1;32m==>\033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
	else
		printf "==> ${mesg}\n" "$@" >&2
	fi
}

msg2() {
	local mesg=$1; shift
	if [ $COLORMSG -eq 1 ]; then
		printf "\033[1;34m  ->\033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
	else
		printf "  -> ${mesg}\n" "$@" >&2
	fi
}

warning() {
	local mesg=$1; shift
	if [ $COLORMSG -eq 1 ]; then
		printf "\033[1;33m==> $(gettext "WARNING:")\033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
	else
		printf "==> $(gettext "WARNING:") ${mesg}\n" "$@" >&2
	fi
}

error() {
	local mesg=$1; shift
	if [ $COLORMSG -eq 1 ]; then
		printf "\033[1;31m==> $(gettext "ERROR:")\033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
	else
		printf "==> $(gettext "ERROR:") ${mesg}\n" "$@" >&2
	fi
}


##
# Special exit call for traps, Don't print any error messages when inside,
# the fakeroot call, the error message will be printed by the main call.
##
trap_exit() {
	if [ "$INFAKEROOT" -eq 0 ]; then
		echo
		error "$@"
	fi
	exit 1
}


##
# Clean up function. Called automatically when the script exits.
##
clean_up() {
	local EXIT_CODE=$?

	if [ "$INFAKEROOT" -eq 1 ]; then
		# Don't clean up when leaving fakeroot, we're not done yet.
		return
	fi

	if [ $EXIT_CODE -eq 0 -a "$CLEANUP" -eq 1 ]; then
		# If it's a clean exit and -c/--clean has been passed...
		msg "$(gettext "Cleaning up...")"
		rm -rf "$pkgdir" "$srcdir"
		if [ -n "$pkgname" ]; then
			# Can't do this unless the BUILDSCRIPT has been sourced.
			rm -f "${pkgbase}-${pkgver}-${pkgrel}-${CARCH}-build.log"*
			if [ "$PKGFUNC" -eq 1 ]; then
				rm -f "${pkgbase}-${pkgver}-${pkgrel}-${CARCH}-package.log"*
			elif [ "$SPLITPKG" -eq 1 ]; then
				for pkg in ${pkgname[@]}; do
					rm -f "${pkg}-${pkgver}-${pkgrel}-${CARCH}-package.log"*
				done
			fi
		fi
	fi

	remove_deps
}


##
# Signal Traps
##
trap 'clean_up' 0
trap 'trap_exit "$(gettext "TERM signal caught. Exiting...")"' TERM HUP QUIT
trap 'trap_exit "$(gettext "Aborted by user! Exiting...")"' INT
trap 'trap_exit "$(gettext "An unknown error has occured. Exiting...")"' ERR

# a source entry can have two forms :
# 1) "filename::http://path/to/file"
# 2) "http://path/to/file"

# extract the filename from a source entry
get_filename() {
	# if a filename is specified, use it
	local filename=$(echo $1 | sed 's|::.*||')
	# if it is just an url, we only keep the last component
	echo "$filename" | sed 's|^.*://.*/||g'
}

# extract the url from a source entry
get_url() {
	# strip an eventual filename
	echo $1 | sed 's|.*::||'
}

##
# Checks to see if options are present in makepkg.conf or PKGBUILD;
# PKGBUILD options always take precedence.
#
#  usage : check_option( $option )
# return : y - enabled
#          n - disabled
#          ? - not found
##
check_option() {
	local ret=$(in_opt_array "$1" ${options[@]})
	if [ "$ret" != '?' ]; then
		echo $ret
		return
	fi

	# fall back to makepkg.conf options
	ret=$(in_opt_array "$1" ${OPTIONS[@]})
	if [ "$ret" != '?' ]; then
		echo $ret
		return
	fi

	echo '?' # Not Found
}


##
# Check if option is present in BUILDENV
#
#  usage : check_buildenv( $option )
# return : y - enabled
#          n - disabled
#          ? - not found
##
check_buildenv() {
	echo $(in_opt_array "$1" ${BUILDENV[@]})
}


##
#  usage : in_opt_array( $needle, $haystack )
# return : y - enabled
#          n - disabled
#          ? - not found
##
in_opt_array() {
	local needle=$(echo $1 | tr '[:upper:]' '[:lower:]'); shift

	local opt
	for opt in "$@"; do
		opt=$(echo $opt | tr '[:upper:]' '[:lower:]')
		if [ "$opt" = "$needle" ]; then
			echo 'y' # Enabled
			return
		elif [ "$opt" = "!$needle" ]; then
			echo 'n' # Disabled
			return
		fi
	done

	echo '?' # Not Found
}


##
#  usage : in_array( $needle, $haystack )
# return : 0 - found
#          1 - not found
##
in_array() {
	local needle=$1; shift
	[ -z "$1" ] && return 1 # Not Found
	local item
	for item in "$@"; do
		[ "$item" = "$needle" ] && return 0 # Found
	done
	return 1 # Not Found
}

get_downloadclient() {
	# $1 = url with valid protocol prefix
	local url=$1
	local proto=$(echo "$url" | sed 's|://.*||')

	# loop through DOWNLOAD_AGENTS variable looking for protocol
	local i
	for i in "${DLAGENTS[@]}"; do
		local handler=$(echo $i | sed 's|::.*||')
		if [ "$proto" = "$handler" ]; then
			agent=$(echo $i | sed 's|^.*::||')
			break
		fi
	done

	# if we didn't find an agent, return an error
	if [ -z "$agent" ]; then
		error "$(gettext "There is no agent set up to handle %s URLs. Check %s.")" "$proto" "$MAKEPKG_CONF"
		plain "$(gettext "Aborting...")"
		exit 1 # $E_CONFIG_ERROR
	fi

	# ensure specified program is installed
	local program="$(echo $agent | awk '{print $1 }')"
	if [ ! -x "$program" ]; then
		local baseprog=$(basename $program)
		error "$(gettext "The download program %s is not installed.")" "$baseprog"
		plain "$(gettext "Aborting...")"
		exit 1 # $E_MISSING_PROGRAM
	fi

	echo "$agent"
}

download_file() {
	# download command
	local dlcmd=$1
	# url of the file
	local url=$2
	# destination file
	local file=$3
	# temporary download file, default to last component of the url
	local dlfile=$(echo "$url" | sed 's|^.*://.*/||g')

	# replace %o by the temporary dlfile if it exists
	if echo "$dlcmd" | grep -q "%o" ; then
		dlcmd=${dlcmd//\%o/\"$file.part\"}
		dlfile="$file.part"
	fi
	# add the url, either in place of %u or at the end
	if echo "$dlcmd" | grep -q "%u" ; then
		dlcmd=${dlcmd//\%u/\"$url\"}
	else
		dlcmd="$dlcmd \"$url\""
	fi

	eval $dlcmd || return $?

	# rename the temporary download file to the final destination
	if [ "$dlfile" != "$file" ]; then
		mv -f "$SRCDEST/$dlfile" "$SRCDEST/$file"
	fi
}

check_deps() {
	[ $# -gt 0 ] || return

	pmout=$(pacman $PACMAN_OPTS -T "$@")
	ret=$?
	if [ $ret -eq 127 ]; then #unresolved deps
		echo "$pmout"
	elif [ $ret -ne 0 ]; then
		error "$(gettext "Pacman returned a fatal error (%i): %s")" "$ret" "$pmout"
		exit 1
	fi
}

handledeps() {
	local R_DEPS_SATISFIED=0
	local R_DEPS_MISSING=1

	[ $# -eq 0 ] && return $R_DEPS_SATISFIED

	local deplist="$*"

	if [ "$DEP_BIN" -eq 0 ]; then
		return $R_DEPS_MISSING
	fi

	if [ "$DEP_BIN" -eq 1 ]; then
		# install missing deps from binary packages (using pacman -S)
		msg "$(gettext "Installing missing dependencies...")"
		local ret=0

		if [ "$ASROOT" -eq 0 ]; then
			sudo pacman $PACMAN_OPTS -S --asdeps $deplist || ret=$?
		else
			pacman $PACMAN_OPTS -S --asdeps $deplist || ret=$?
		fi

		if [ $ret -ne 0 ]; then
			error "$(gettext "Pacman failed to install missing dependencies.")"
			exit 1 # TODO: error code
		fi
	fi

	# we might need the new system environment
	# set -e can cause problems during sourcing profile scripts
	set +e
	source /etc/profile &>/dev/null
	set -e

	return $R_DEPS_SATISFIED
}

resolve_deps() {
	# $pkgdeps is a GLOBAL variable, used by remove_deps()
	local R_DEPS_SATISFIED=0
	local R_DEPS_MISSING=1

	local deplist="$(check_deps $*)"
	if [ -z "$deplist" ]; then
		return $R_DEPS_SATISFIED
	fi

	if handledeps $deplist; then
		pkgdeps="$pkgdeps $deplist"
		# check deps again to make sure they were resolved
		deplist="$(check_deps $*)"
		[ -z "$deplist" ] && return $R_DEPS_SATISFIED
	elif [ "$DEP_BIN" -eq 1 ]; then
		error "$(gettext "Failed to install all missing dependencies.")"
	fi

	msg "$(gettext "Missing Dependencies:")"
	local dep
	for dep in $deplist; do
		msg2 "$dep"
	done

	return $R_DEPS_MISSING
}

# fix flyspray bug #5923
remove_deps() {
	# $pkgdeps is a GLOBAL variable, set by resolve_deps()
	[ "$RMDEPS" -eq 0 ] && return
	[ -z "$pkgdeps" ] && return

	local dep depstrip deplist
	deplist=""
	for dep in $pkgdeps; do
		depstrip=$(echo $dep | sed -e 's|=.*$||' -e 's|>.*$||' -e 's|<.*$||')
		deplist="$deplist $depstrip"
	done

	msg "Removing installed dependencies..."
	local ret=0
	if [ "$ASROOT" -eq 0 ]; then
		sudo pacman $PACMAN_OPTS -Rns $deplist || ret=$?
	else
		pacman $PACMAN_OPTS -Rns $deplist || ret=$?
	fi

	# Fixes FS#10039 - exit cleanly as package has built successfully
	if [ $ret -ne 0 ]; then
		warning "$(gettext "Failed to remove installed dependencies.")"
		return 0
	fi
}

download_sources() {
	msg "$(gettext "Retrieving Sources...")"

	if [ ! -w "$SRCDEST" ] ; then
		error "$(gettext "You do not have write permission to store downloads in %s.")" "$SRCDEST"
		plain "$(gettext "Aborting...")"
		exit 1
	fi

	pushd "$SRCDEST" &>/dev/null

	local netfile
	for netfile in "${source[@]}"; do
		local file=$(get_filename "$netfile")
		local url=$(get_url "$netfile")
		if [ -f "$startdir/$file" ]; then
			msg2 "$(gettext "Found %s in build dir")" "$file"
			rm -f "$srcdir/$file"
			ln -s "$startdir/$file" "$srcdir/"
			continue
		elif [ -f "$SRCDEST/$file" ]; then
			msg2 "$(gettext "Using cached copy of %s")" "$file"
			rm -f "$srcdir/$file"
			ln -s "$SRCDEST/$file" "$srcdir/"
			continue
		fi

		# if we get here, check to make sure it was a URL, else fail
		if [ "$file" = "$url" ]; then
			error "$(gettext "%s was not found in the build directory and is not a URL.")" "$file"
			exit 1 # $E_MISSING_FILE
		fi

		# find the client we should use for this URL
		local dlclient=$(get_downloadclient "$url") || exit $?

		msg2 "$(gettext "Downloading %s...")" "$file"
		# fix flyspray bug #3289
		local ret=0
		download_file "$dlclient" "$url" "$file" || ret=$?
		if [ $ret -gt 0 ]; then
			error "$(gettext "Failure while downloading %s")" "$file"
			plain "$(gettext "Aborting...")"
			exit 1
		fi
		rm -f "$srcdir/$file"
		ln -s "$SRCDEST/$file" "$srcdir/"
	done

	popd &>/dev/null
}

generate_checksums() {
	msg "$(gettext "Generating checksums for source files...")"
	plain ""

	if [ ! $(type -p openssl) ]; then
		error "$(gettext "Cannot find openssl.")"
		exit 1 # $E_MISSING_PROGRAM
	fi

	local integ
	for integ in ${INTEGRITY_CHECK[@]}; do
		integ="$(echo $integ | tr '[:upper:]' '[:lower:]')"
		case "$integ" in
			md5|sha1|sha256|sha384|sha512) : ;;
			*)
				error "$(gettext "Invalid integrity algorithm '%s' specified.")" "$integ"
				exit 1;; # $E_CONFIG_ERROR
		esac

		local ct=0
		local numsrc=${#source[@]}
		echo -n "${integ}sums=("

		local i=0;
		local indent=''
		while [ $i -lt $((${#integ}+6)) ]; do
			indent="$indent "
			i=$(($i+1))
		done

		local netfile
		for netfile in "${source[@]}"; do
			local file="$(get_filename "$netfile")"

			if [ ! -f "$file" ] ; then
				if [ ! -f "$SRCDEST/$file" ] ; then
					error "$(gettext "Unable to find source file %s to generate checksum.")" "$file"
					plain "$(gettext "Aborting...")"
					exit 1
				else
					file="$SRCDEST/$file"
				fi
			fi

			local sum="$(openssl dgst -${integ} "$file" | awk '{print $NF}')"
			[ $ct -gt 0 ] && echo -n "$indent"
			echo -n "'$sum'"
			ct=$(($ct+1))
			[ $ct -lt $numsrc ] && echo
		done

		echo ")"
	done
}

check_checksums() {
	[ ${#source[@]} -eq 0 ] && return 0

	if [ ! $(type -p openssl) ]; then
		error "$(gettext "Cannot find openssl.")"
		exit 1 # $E_MISSING_PROGRAM
	fi

	local correlation=0
	local integ required
	for integ in md5 sha1 sha256 sha384 sha512; do
		local integrity_sums=($(eval echo "\${${integ}sums[@]}"))
		if [ ${#integrity_sums[@]} -eq ${#source[@]} ]; then
			msg "$(gettext "Validating source files with %s...")" "${integ}sums"
			correlation=1
			local errors=0
			local idx=0
			local file
			for file in "${source[@]}"; do
				local found=1
				file="$(get_filename "$file")"
				echo -n "    $file ... " >&2

				if [ ! -f "$file" ] ; then
					if [ ! -f "$SRCDEST/$file" ] ; then
						echo "$(gettext "NOT FOUND")" >&2
						errors=1
						found=0
					else
						file="$SRCDEST/$file"
					fi
				fi

				if [ $found -gt 0 ] ; then
					local expectedsum="$(echo ${integrity_sums[$idx]} | tr '[A-F]' '[a-f]')"
					local realsum="$(openssl dgst -${integ} "$file" | awk '{print $NF}')"
					if [ "$expectedsum" = "$realsum" ]; then
						echo "$(gettext "Passed")" >&2
					else
						echo "$(gettext "FAILED")" >&2
						errors=1
					fi
				fi

				idx=$((idx + 1))
			done

			if [ $errors -gt 0 ]; then
				error "$(gettext "One or more files did not pass the validity check!")"
				exit 1 # TODO: error code
			fi
		elif [ ${#integrity_sums[@]} -gt 0 ]; then
			error "$(gettext "Integrity checks (%s) differ in size from the source array.")" "$integ"
			exit 1 # TODO: error code
		fi
	done

# not so strict, mate
#	if [ $correlation -eq 0 ]; then
#		error "$(gettext "Integrity checks are missing.")"
#		exit 1 # TODO: error code
#	fi
}

extract_sources() {
	msg "$(gettext "Extracting Sources...")"
	local netfile
	for netfile in "${source[@]}"; do
		file=$(get_filename "$netfile")
		if in_array "$file" ${noextract[@]}; then
			#skip source files in the noextract=() array
			#  these are marked explicitly to NOT be extracted
			continue
		fi

		if [ ! -f "$file" ] ; then
			if [ ! -f "$SRCDEST/$file" ] ; then
				error "$(gettext "Unable to find source file %s for extraction.")" "$file"
				plain "$(gettext "Aborting...")"
				exit 1
			else
				file="$SRCDEST/$file"
			fi
		fi

		# fix flyspray #6246
		local file_type=$(file -bizL "$file")
		local cmd=''
		case "$file_type" in
			*application/x-tar*|*application/zip*|*application/x-zip*|*application/x-cpio*)
				cmd="bsdtar -x -f" ;;
			*application/x-gzip*)
				cmd="gunzip -d -f" ;;
			*application/x-bzip*)
				cmd="bunzip2 -f" ;;
			*application/x-xz*)
				cmd="xz -d -f" ;;
			*)
				# Don't know what to use to extract this file,
				# skip to the next file
				continue;;
		esac

		local ret=0
		msg2 '%s' "$cmd \"$file\""
		$cmd "$file" || ret=$?
		if [ $ret -ne 0 ]; then
			error "$(gettext "Failed to extract %s")" "$file"
			plain "$(gettext "Aborting...")"
			exit 1
		fi
	done

	if [ $EUID -eq 0 ]; then
		# change perms of all source files to root user & root group
		chown -R 0:0 "$srcdir"
	fi
}

run_build() {
	# use distcc if it is requested (check buildenv and PKGBUILD opts)
	if [ "$(check_buildenv distcc)" = "y" -a "$(check_option distcc)" != "n" ]; then
		[ -d /usr/lib/distcc/bin ] && export PATH="/usr/lib/distcc/bin:$PATH"
		export DISTCC_HOSTS
	elif [ "$(check_option distcc)" = "n" ]; then
		# if it is not wanted, clear the makeflags too
		MAKEFLAGS=""
	fi

	# use ccache if it is requested (check buildenv and PKGBUILD opts)
	if [ "$(check_buildenv ccache)" = "y" -a "$(check_option ccache)" != "n" ]; then
		[ -d /usr/lib/ccache/bin ] && export PATH="/usr/lib/ccache/bin:$PATH"
	fi

	# clear user-specified makeflags if requested
	if [ "$(check_option makeflags)" = "n" ]; then
		MAKEFLAGS=""
	fi

	msg "$(gettext "Starting build()...")"
	cd "$srcdir"

	# ensure all necessary build variables are exported
	export CFLAGS CXXFLAGS MAKEFLAGS LDFLAGS CHOST
	# save our shell options so build() can't override what we need
	local shellopts=$(shopt -p)

	local ret=0
	if [ "$LOGGING" -eq 1 ]; then
		BUILDLOG="${startdir}/${pkgbase}-${pkgver}-${pkgrel}-${CARCH}-build.log"
		if [ -f "$BUILDLOG" ]; then
			local i=1
			while true; do
				if [ -f "$BUILDLOG.$i" ]; then
					i=$(($i +1))
				else
					break
				fi
			done
			mv "$BUILDLOG" "$BUILDLOG.$i"
		fi

		build 2>&1 | tee "$BUILDLOG"; ret=${PIPESTATUS[0]}
	else
		build 2>&1 || ret=$?
	fi
	# reset our shell options
	eval "$shellopts"

	if [ $ret -gt 0 ]; then
		error "$(gettext "Build Failed.")"
		plain "$(gettext "Aborting...")"
		remove_deps
		exit 2 # $E_BUILD_FAILED
	fi
}

run_package() {
	if [ -z "$1" ]; then
		pkgfunc="package"
		nameofpkg="$pkgname"
	else
		pkgfunc="package_$1"
		nameofpkg="$1"
	fi

	# clear user-specified makeflags if requested
	if [ "$(check_option makeflags)" = "n" ]; then
		MAKEFLAGS=""
	fi

	msg "$(gettext "Starting %s()...")" "$pkgfunc"
	cd "$srcdir"

	# ensure all necessary build variables are exported
	export CFLAGS CXXFLAGS LDFLAGS MAKEFLAGS CHOST

	local ret=0
	if [ "$LOGGING" -eq 1 ]; then
		BUILDLOG="${startdir}/${nameofpkg}-${pkgver}-${pkgrel}-${CARCH}-package.log"
		if [ -f "$BUILDLOG" ]; then
			local i=1
			while true; do
				if [ -f "$BUILDLOG.$i" ]; then
					i=$(($i +1))
				else
					break
				fi
			done
			mv "$BUILDLOG" "$BUILDLOG.$i"
		fi

		# ensure overridden package variables suvrive tee with split packages
		logpipe=$(mktemp -u "$startdir/logpipe.XXXXXXXX")
		mknod "$logpipe" p
		exec 3>&1
		tee "$BUILDLOG" < "$logpipe" &
		exec 1>"$logpipe" 2>"$logpipe"
		$pkgfunc 2>&1 || ret=$?
		sync
		exec 1>&3 2>&3 3>&-
		rm "$logpipe"
	else
		$pkgfunc 2>&1 || ret=$?
	fi

	if [ $ret -gt 0 ]; then
		error "$(gettext "Packaging Failed.")"
		plain "$(gettext "Aborting...")"
		remove_deps
		exit 2 # $E_BUILD_FAILED
	fi
}

tidy_install() {
	cd "$pkgdir"
	msg "$(gettext "Tidying install...")"

	if [ "$(check_option docs)" = "n" -a -n "${DOC_DIRS[*]}" ]; then
		msg2 "$(gettext "Removing doc files...")"
		rm -rf ${DOC_DIRS[@]}
	fi

	if [ "$(check_option purge)" = "y" -a -n "${PURGE_TARGETS[*]}" ]; then
		msg2 "$(gettext "Purging other files...")"
		local pt
		for pt in "${PURGE_TARGETS[@]}"; do
			if [ "${pt}" = "${pt//\/}" ]; then
				find . -type f -name "${pt}" -exec rm -f -- '{}' \;
			else
				rm -f ${pt}
			fi
		done
	fi

	if [ "$(check_option zipman)" = "y" -a -n "${MAN_DIRS[*]}" ]; then
		msg2 "$(gettext "Compressing man and info pages...")"
		local manpage ext file link hardlinks hl
		find ${MAN_DIRS[@]} -type f 2>/dev/null |
		while read manpage ; do
			# check file still exists (potentially compressed with hard link)
			if [ -f ${manpage} ]; then
				ext="${manpage##*.}"
				file="${manpage##*/}"
				if [ "$ext" != "gz" -a "$ext" != "bz2" ]; then
					# update symlinks to this manpage
					find ${MAN_DIRS[@]} -lname "$file" 2>/dev/null |
					while read link ; do
						rm -f "$link"
						ln -sf "${file}.gz" "${link}.gz"
					done
					# find hard links and remove them
					#   the '|| true' part keeps the script from bailing if find returned an
					#   error, such as when one of the man directories doesn't exist
					hardlinks="$(find ${MAN_DIRS[@]} \! -name "$file" -samefile "$manpage" 2>/dev/null)" || true
					for hl in ${hardlinks}; do
						rm -f "${hl}";
					done
					# compress the original
					gzip -9 "$manpage"
					# recreate hard links removed earlier
					for hl in ${hardlinks}; do
						ln "${manpage}.gz" "${hl}.gz"
						chmod 644 ${hl}.gz
					done
				fi
			fi
		done
	fi

	if [ "$(check_option splitdbg)" = "y" ] || [ "$SPLIT_DBG" = "1" ]; then
		msg2 "$(gettext "Moving debugging symbols from binaries and libraries into separate files...")"
		local binary
		if [ -z "${STRIP_DIRS[*]}" ]; then
			# fall back to default value
			STRIP_DIRS=(bin lib sbin usr/{bin,lib,sbin,local/{bin,lib,sbin}}
			opt/*/{bin,lib,sbin})
		fi
		find ${STRIP_DIRS[@]} -type f 2>/dev/null | while read binary ; do
			case "$(file -biz "$binary")" in
				*application/x-sharedlib*)  # Libraries (.so)
					/usr/bin/objcopy --only-keep-debug "$binary" "$binary.debug"
					/usr/bin/strip --strip-debug --strip-unneeded "$binary"
					debug_basebinary=`echo "$binary" | awk -F '/' '{print $NF}'`
					debug_symbolfile=`echo "$binary.debug" | awk -F '/' '{print $NF}'`
					debug_basedir=`dirname "$binary.debug"`
					pushd $debug_basedir &>/dev/null
						/usr/bin/objcopy --add-gnu-debuglink="$debug_symbolfile" "$debug_basebinary" 
					popd &>/dev/null
					if [ ! -d "${dbgdir}/usr/lib/debug/${debug_basedir}" ]; then
						mkdir -p "${dbgdir}/usr/lib/debug/${debug_basedir}"
					fi
					mv "$binary.debug" "${dbgdir}/usr/lib/debug/${debug_basedir}/$debug_symbolfile";;
				*application/x-archive*)  # Libraries (.a)
					/usr/bin/objcopy --only-keep-debug "$binary" "$binary.debug"
					/usr/bin/strip --strip-debug --strip-unneeded "$binary"
					debug_basebinary=`echo "$binary" | awk -F '/' '{print $NF}'`
					debug_symbolfile=`echo "$binary.debug" | awk -F '/' '{print $NF}'`
					debug_basedir=`dirname "$binary.debug"`
					pushd $debug_basedir &>/dev/null
						/usr/bin/objcopy --add-gnu-debuglink="$debug_symbolfile" "$debug_basebinary" 
					popd &>/dev/null
					if [ ! -d "${dbgdir}/usr/lib/debug/${debug_basedir}" ]; then
						mkdir -p "${dbgdir}/usr/lib/debug/${debug_basedir}"
					fi
					mv "$binary.debug" "${dbgdir}/usr/lib/debug/${debug_basedir}/$debug_symbolfile";;
				*application/x-executable*) # Binaries
					/usr/bin/objcopy --only-keep-debug "$binary" "$binary.debug"
					/usr/bin/strip --strip-debug --strip-unneeded "$binary"
					debug_basebinary=`echo "$binary" | awk -F '/' '{print $NF}'`
					debug_symbolfile=`echo "$binary.debug" | awk -F '/' '{print $NF}'`
					debug_basedir=`dirname "$binary.debug"`
					pushd $debug_basedir &>/dev/null
						/usr/bin/objcopy --add-gnu-debuglink="$debug_symbolfile" "$debug_basebinary" 
					popd &>/dev/null
					if [ ! -d "${dbgdir}/usr/lib/debug/${debug_basedir}" ]; then
						mkdir -p "${dbgdir}/usr/lib/debug/${debug_basedir}"
					fi
					mv "$binary.debug" "${dbgdir}/usr/lib/debug/${debug_basedir}/$debug_symbolfile";;
			esac
		done
	fi

	if [ "$(check_option strip)" = "y" -a -n "${STRIP_DIRS[*]}" ]; then
		msg2 "$(gettext "Stripping debugging symbols from binaries and libraries...")"
		local binary
		find ${STRIP_DIRS[@]} -type f 2>/dev/null | while read binary ; do
			case "$(file -biz "$binary")" in
				*compressed-encoding*)      # Skip compressed binarys
					;;
				*application/x-sharedlib*)  # Libraries (.so)
					/usr/bin/strip -S "$binary";;
				*application/x-archive*)    # Libraries (.a)
					/usr/bin/strip -S "$binary";;
				*application/x-executable*) # Binaries
					/usr/bin/strip "$binary";;
			esac
		done
	fi

	if [ "$(check_option splithdr)" = "y" ] || [ "$SPLIT_HDR" = "1" ]; then
		msg2 "$(gettext "Moving header files into separate package...")"
		
		# this is very hardcoded stuff
		if [ -d "${pkgdir}/usr/include" ]; then
			msg "DEBUG: moving headers..."
			ls -la ${pkgdir}/usr/include
			# move headers into new package
			mkdir -p ${hdrdir}/usr
			mv -v ${pkgdir}/usr/include ${hdrdir}/usr
		fi
		
		if [ -d "${pkgdir}/usr/share/apps/cmake" ]; then
			msg "DEBUG: moving .cmake files..."
			ls -la ${pkgdir}/usr/share/apps/cmake
			# also move .cmake files into the new package
			mkdir -p ${hdrdir}/usr/share/apps
			mv -v ${pkgdir}/usr/share/apps/cmake ${hdrdir}/usr/share/apps
		fi
	fi

	if [ "$(check_option libtool)" = "n" ]; then
		msg2 "$(gettext "Removing libtool .la files...")"
		find . ! -type d -name "*.la" -exec rm -f -- '{}' \;
	fi

	if [ "$(check_option emptydirs)" = "n" ]; then
		msg2 "$(gettext "Removing empty directories...")"
		find . -depth -type d -empty -delete
	fi
}

write_pkginfo() {
	local builddate=$(date -u "+%s")
	if [ -n "$PACKAGER" ]; then
		local packager="$PACKAGER"
	else
		local packager="Unknown Packager"
	fi
	local size=$(du -sk | awk '{print $1 * 1024}')

	msg2 "$(gettext "Generating .PKGINFO file...")"
	echo "# Generated by makepkg $myver" >.PKGINFO
	if [ "$INFAKEROOT" -eq 1 ]; then
		echo "# using $(fakeroot -v)" >>.PKGINFO
	fi
	echo "# $(LC_ALL=C date -u)" >>.PKGINFO
	echo "pkgname = $1" >>.PKGINFO
	[ "$SPLITPKG" -eq 1 ] && echo "pkgbase = $pkgbase" >>.PKGINFO
	echo "pkgver = $pkgver-$pkgrel" >>.PKGINFO
	echo "pkgdesc = $pkgdesc" >>.PKGINFO
	echo "url = $url" >>.PKGINFO
	echo "builddate = $builddate" >>.PKGINFO
	echo "packager = $packager" >>.PKGINFO
	echo "size = $size" >>.PKGINFO
	if [ -n "$CARCH" ]; then
		echo "arch = $CARCH" >>.PKGINFO
	fi
	if [ "$(check_option force)" = "y" ]; then
		echo "force = true" >> .PKGINFO
	fi

	local it
	for it in "${license[@]}"; do
		echo "license = $it" >>.PKGINFO
	done
	for it in "${replaces[@]}"; do
		echo "replaces = $it" >>.PKGINFO
	done
	for it in "${groups[@]}"; do
		echo "group = $it" >>.PKGINFO
	done
	for it in "${depends[@]}"; do
		echo "depend = $it" >>.PKGINFO
	done
	for it in "${optdepends[@]}"; do
		echo "optdepend = $it" >>.PKGINFO
	done
	for it in "${conflicts[@]}"; do
		echo "conflict = $it" >>.PKGINFO
	done
	for it in "${provides[@]}"; do
		echo "provides = $it" >>.PKGINFO
	done
	for it in "${backup[@]}"; do
		echo "backup = $it" >>.PKGINFO
	done
	for it in "${packaging_options[@]}"; do
		local ret="$(check_option $it)"
		if [ "$ret" != "?" ]; then
			if [ "$ret" = "y" ]; then
				echo "makepkgopt = $it" >>.PKGINFO
			else
				echo "makepkgopt = !$it" >>.PKGINFO
			fi
		fi
	done

	# TODO maybe remove this at some point
	# warn if license array is not present or empty
	if [ -z "$license" ]; then
		warning "$(gettext "Please add a license line to your %s!")" "$BUILDSCRIPT"
		plain "$(gettext "Example for GPL\'ed software: license=('GPL').")"
	fi
}

write_debug_pkginfo() {
	local builddate=$(date -u "+%s")
	if [ -n "$PACKAGER" ]; then
		local packager="$PACKAGER"
	else
		local packager="Unknown Packager"
	fi
	local size=$(du -sk | awk '{print $1 * 1024}')

	msg2 "$(gettext "Generating .PKGINFO file...")"
	echo "# Generated by makepkg $myver" >.PKGINFO
	if [ "$INFAKEROOT" -eq 1 ]; then
		echo "# using $(fakeroot -v)" >>.PKGINFO
	fi
	echo "# $(LC_ALL=C date -u)" >>.PKGINFO
	echo "pkgname = $1-debug" >>.PKGINFO
	[ "$SPLITPKG" -eq 1 ] && echo "pkgbase = $pkgbase" >>.PKGINFO
	echo "pkgver = $pkgver-$pkgrel" >>.PKGINFO
	echo "pkgdesc = $pkgdesc (Debugging Symbols)" >>.PKGINFO
	echo "url = $url" >>.PKGINFO
	echo "builddate = $builddate" >>.PKGINFO
	echo "packager = $packager" >>.PKGINFO
	echo "size = $size" >>.PKGINFO
	if [ -n "$CARCH" ]; then
		echo "arch = $CARCH" >>.PKGINFO
	fi

	echo "group = kdemod-debug" >>.PKGINFO
	[ "$SPLITPKG" -eq 1 ] && echo "group = $pkgbase-debug" >>.PKGINFO
	echo "group = kdemod-uninstall" >>.PKGINFO

	local it
	for it in "${packaging_options[@]}"; do
		local ret="$(check_option $it)"
		if [ "$ret" != "?" ]; then
			if [ "$ret" = "y" ]; then
				echo "makepkgopt = $it" >>.PKGINFO
			else
				echo "makepkgopt = !$it" >>.PKGINFO
			fi
		fi
	done

	# TODO maybe remove this at some point
	# warn if license array is not present or empty
	if [ -z "$license" ]; then
		warning "$(gettext "Please add a license line to your %s!")" "$BUILDSCRIPT"
		plain "$(gettext "Example for GPL\'ed software: license=('GPL').")"
	fi
}

write_header_pkginfo() {
	local builddate=$(date -u "+%s")
	if [ -n "$PACKAGER" ]; then
		local packager="$PACKAGER"
	else
		local packager="Unknown Packager"
	fi
	local size=$(du -sk | awk '{print $1 * 1024}')

	msg2 "$(gettext "Generating .PKGINFO file...")"
	echo "# Generated by makepkg $myver" >.PKGINFO
	if [ "$INFAKEROOT" -eq 1 ]; then
		echo "# using $(fakeroot -v)" >>.PKGINFO
	fi
	echo "# $(LC_ALL=C date -u)" >>.PKGINFO
	echo "pkgname = $1-devel" >>.PKGINFO
	[ "$SPLITPKG" -eq 1 ] && echo "pkgbase = $pkgbase" >>.PKGINFO
	echo "pkgver = $pkgver-$pkgrel" >>.PKGINFO
	echo "pkgdesc = $pkgdesc (Development Headers)" >>.PKGINFO
	echo "url = $url" >>.PKGINFO
	echo "builddate = $builddate" >>.PKGINFO
	echo "packager = $packager" >>.PKGINFO
	echo "size = $size" >>.PKGINFO
	if [ -n "$CARCH" ]; then
		echo "arch = $CARCH" >>.PKGINFO
	fi
	if [ "$(check_option force)" = "y" ]; then
		echo "force = true" >> .PKGINFO
	fi

	local it
	for it in "${license[@]}"; do
		echo "license = $it" >>.PKGINFO
	done

	echo "depends = $nameofpkg" >>.PKGINFO
        echo "group = kdemod-devel" >>.PKGINFO
	echo "group = kdemod-headers" >>.PKGINFO
	echo "group = kdemod-uninstall" >>.PKGINFO

	for it in "${packaging_options[@]}"; do
		local ret="$(check_option $it)"
		if [ "$ret" != "?" ]; then
			if [ "$ret" = "y" ]; then
				echo "makepkgopt = $it" >>.PKGINFO
			else
				echo "makepkgopt = !$it" >>.PKGINFO
			fi
		fi
	done

	# TODO maybe remove this at some point
	# warn if license array is not present or empty
	if [ -z "$license" ]; then
		warning "$(gettext "Please add a license line to your %s!")" "$BUILDSCRIPT"
		plain "$(gettext "Example for GPL\'ed software: license=('GPL').")"
	fi
}

create_package() {
	if [ ! -d "$pkgdir" ]; then
		error "$(gettext "Missing pkg/ directory.")"
		plain "$(gettext "Aborting...")"
		exit 1 # $E_MISSING_PKGDIR
	fi

	if [ -z "$1" ]; then
		nameofpkg="$pkgname"
	else
		nameofpkg="$1"
	fi

	cd "$pkgdir"
	write_pkginfo $nameofpkg

	cd "$pkgdir"
	msg "$(gettext "Creating package...")"

	local comp_files=".PKGINFO"

	# check for an install script
	if [ -n "$install" ]; then
		msg2 "$(gettext "Adding install script...")"
		cp "$startdir/$install" .INSTALL
		comp_files="$comp_files .INSTALL"
	fi

	# do we have a changelog?
	if [ -f "$startdir/ChangeLog" ]; then
		msg2 "$(gettext "Adding package changelog...")"
		cp "$startdir/ChangeLog" .CHANGELOG
		comp_files="$comp_files .CHANGELOG"
	fi

	# tar it up
	msg2 "$(gettext "Compressing package...")"

	case "$PKGEXT" in
		*tar.gz)  EXT=${PKGEXT%.gz} ;;
		*tar.bz2) EXT=${PKGEXT%.bz2} ;;
		*tar.xz)  EXT=${PKGEXT%.xz} ;;
		*) warning "$(gettext "'%s' is not a valid archive extension.")" \
		"$PKGEXT" ; EXT=$PKGEXT ;;
	esac
	local pkg_file="$PKGDEST/${nameofpkg}-${pkgver}-${pkgrel}-${CARCH}${EXT}"

	local ret=0

	# when fileglobbing, we want * in an empty directory to expand to
	# the null string rather than itself
	shopt -s nullglob
	bsdtar -cf - $comp_files * > "$pkg_file" || ret=$?
	shopt -u nullglob

	if [ $ret -eq 0 ]; then
		case "$PKGEXT" in
			*tar.gz)  gzip -f -n "$pkg_file" ;;
			*tar.bz2) bzip2 -f "$pkg_file" ;;
			*tar.xz)  xz -z -f "$pkg_file" ;;
		esac
		ret=$?
	fi

	if [ $ret -ne 0 ]; then
		error "$(gettext "Failed to create package file.")"
		exit 1 # TODO: error code
	fi
}

create_debug_package() {
	if [ ! -d "$dbgdir" ]; then
		error "$(gettext "Missing dbg/ directory.")"
		plain "$(gettext "Aborting...")"
		exit 1 # $E_MISSING_PKGDIR
	fi

	if [ -z "$1" ]; then
		nameofpkg="$pkgname"
	else
		nameofpkg="$1"
	fi

	cd "$dbgdir"
	write_debug_pkginfo $nameofpkg

	cd "$dbgdir"
	msg "$(gettext "Creating package...")"

	local comp_files=".PKGINFO"

	# tar it up
	msg2 "$(gettext "Compressing package...")"

	case "$PKGEXT" in
		*tar.gz)  EXT=${PKGEXT%.gz} ;;
		*tar.bz2) EXT=${PKGEXT%.bz2} ;;
		*tar.xz)  EXT=${PKGEXT%.xz} ;;
		*) warning "$(gettext "'%s' is not a valid archive extension.")" \
		"$PKGEXT" ; EXT=$PKGEXT ;;
	esac
	local pkg_file="$PKGDEST/${nameofpkg}-debug-${pkgver}-${pkgrel}-${CARCH}${EXT}"

	local ret=0

	# when fileglobbing, we want * in an empty directory to expand to
	# the null string rather than itself
	shopt -s nullglob
	bsdtar -cf - $comp_files * > "$pkg_file" || ret=$?
	shopt -u nullglob

	if [ $ret -eq 0 ]; then
		case "$PKGEXT" in
			*tar.gz)  gzip -f -n "$pkg_file" ;;
			*tar.bz2) bzip2 -f "$pkg_file" ;;
			*tar.xz)  xz -z -f "$pkg_file" ;;
		esac
		ret=$?
	fi

	if [ $ret -ne 0 ]; then
		error "$(gettext "Failed to create debug package file.")"
		exit 1 # TODO: error code
	fi
}

create_header_package() {
	if [ ! -d "$hdrdir" ]; then
		error "$(gettext "Missing hdr/ directory.")"
		plain "$(gettext "Aborting...")"
		exit 1 # $E_MISSING_PKGDIR
	fi

	if [ -z "$1" ]; then
		nameofpkg="$pkgname"
	else
		nameofpkg="$1"
	fi

	cd "$hdrdir"
	write_header_pkginfo $nameofpkg

	cd "$hdrdir"
	msg "$(gettext "Creating package...")"

	local comp_files=".PKGINFO"

	# tar it up
	msg2 "$(gettext "Compressing package...")"

	case "$PKGEXT" in
		*tar.gz)  EXT=${PKGEXT%.gz} ;;
		*tar.bz2) EXT=${PKGEXT%.bz2} ;;
		*tar.xz)  EXT=${PKGEXT%.xz} ;;
		*) warning "$(gettext "'%s' is not a valid archive extension.")" \
		"$PKGEXT" ; EXT=$PKGEXT ;;
	esac
	local pkg_file="$PKGDEST/${nameofpkg}-${pkgver}-${pkgrel}-${CARCH}${EXT}"

	local ret=0

	# when fileglobbing, we want * in an empty directory to expand to
	# the null string rather than itself
	shopt -s nullglob
	bsdtar -cf - $comp_files * > "$pkg_file" || ret=$?
	shopt -u nullglob

	if [ $ret -eq 0 ]; then
		case "$PKGEXT" in
			*tar.gz)  gzip -f -n "$pkg_file" ;;
			*tar.bz2) bzip2 -f "$pkg_file" ;;
			*tar.xz)  xz -z -f "$pkg_file" ;;
		esac
		ret=$?
	fi

	if [ $ret -ne 0 ]; then
		error "$(gettext "Failed to create header package file.")"
		exit 1 # TODO: error code
	fi
}

create_header2_package() {
	if [ -z "$1" ]; then
		nameofpkg="$pkgname"
	else
		nameofpkg="$1"
	fi

	if [ ! -d "$hdrdir" ]; then
		error "$(gettext "Missing hdr/ directory.")"
		plain "$(gettext "Aborting...")"
		exit 1 # $E_MISSING_PKGDIR
	fi

	cd "$hdrdir"
	msg "$(gettext "Creating package with header files...")"

	local builddate=$(date -u "+%s")
	if [ -n "$PACKAGER" ]; then
		local packager="$PACKAGER"
	else
		local packager="Unknown Packager"
	fi
	local size=$(du -sk | awk '{print $1 * 1024}')

	# write the .PKGINFO file
	msg2 "$(gettext "Generating .PKGINFO file...")"
	echo "# Generated by makepkg $myver" >.PKGINFO
	if [ "$INFAKEROOT" -eq 1 ]; then
		echo "# using $(fakeroot -v)" >>.PKGINFO
	fi
	echo "# $(LC_ALL=C date -u)" >>.PKGINFO
	echo "pkgname = $nameofpkg-devel" >>.PKGINFO
	echo "pkgver = $pkgver-$pkgrel" >>.PKGINFO
	echo "pkgdesc = $pkgdesc (development files)" >>.PKGINFO
	echo "url = $url" >>.PKGINFO
	echo "builddate = $builddate" >>.PKGINFO
	echo "packager = $packager" >>.PKGINFO
	echo "size = $size" >>.PKGINFO
	if [ -n "$CARCH" ]; then
		echo "arch = $CARCH" >>.PKGINFO
	fi
	if [ "$(check_option force)" = "y" ]; then
		echo "force = true" >> .PKGINFO
	fi

	local it
	for it in "${license[@]}"; do
		echo "license = $it" >>.PKGINFO
	done
	
	echo "depends = $nameofpkg" >>.PKGINFO
        echo "group = kdemod-devel" >>.PKGINFO
	echo "group = kdemod-headers" >>.PKGINFO

	for it in "${packaging_options[@]}"; do
		local ret="$(check_option $it)"
		if [ "$ret" != "?" ]; then
			if [ "$ret" = "y" ]; then
				echo "makepkgopt = $it" >>.PKGINFO
			else
				echo "makepkgopt = !$it" >>.PKGINFO
			fi
		fi
	done

	# TODO maybe remove this at some point
	# warn if license array is not present or empty
	if [ -z "$license" ]; then
		warning "$(gettext "Please add a license line to your %s!")" "$BUILDSCRIPT"
		plain "$(gettext "Example for GPL'ed software: license=('GPL').")"
	fi

	local comp_files=".PKGINFO"

	# tar it up
	msg2 "$(gettext "Compressing package...")"

	local TAR_OPT
	case "$PKGEXT" in
		*tar.gz)  TAR_OPT="z" ;;
		*tar.bz2) TAR_OPT="j" ;;
		*) warning "$(gettext "'%s' is not a valid archive extension.")" \
		"$PKGEXT" ;;
	esac

	local pkg_file="$PKGDEST/${nameofpkg}-devel-${pkgver}-${pkgrel}-${CARCH}${PKGEXT}"

	# when fileglobbing, we want * in an empty directory to expand to
	# the null string rather than itself
	shopt -s nullglob

	if ! bsdtar -c${TAR_OPT}f "$pkg_file" $comp_files *; then
		error "$(gettext "Failed to create package file.")"
		exit 1 # TODO: error code
	fi
	shopt -u nullglob
}

create_srcpackage() {
	cd "$startdir"

	# Get back to our src directory so we can begin with sources.
	mkdir -p "$srcdir"
	cd "$srcdir"
	download_sources
	# We can only check checksums if we have all files.
	check_checksums
	cd "$startdir"

	msg "$(gettext "Creating source package...")"
	local srclinks="$(mktemp -d "$startdir"/srclinks.XXXXXXXXX)"
	mkdir "${srclinks}"/${pkgbase}

	msg2 "$(gettext "Adding %s...")" "$BUILDSCRIPT"
	ln -s "${BUILDFILE}" "${srclinks}/${pkgbase}/${BUILDSCRIPT}"

	if [ -n "$install" ]; then
		if [ -f $install ]; then
			msg2 "$(gettext "Adding install script...")"
			ln -s "${startdir}/$install" "${srclinks}/${pkgbase}/"
		else
			error "$(gettext "Install script %s not found.")" "$install"
		fi
	fi

	if [ -f ChangeLog ]; then
		msg2 "$(gettext "Adding %s...")" "ChangeLog"
		ln -s "${startdir}/ChangeLog" "${srclinks}/${pkgbase}"
	fi

	local netfile
	for netfile in "${source[@]}"; do
		local file=$(get_filename "$netfile")
		if [ -f "$netfile" ]; then
			msg2 "$(gettext "Adding %s...")" "$netfile"
			ln -s "${startdir}/$netfile" "${srclinks}/${pkgbase}"
		elif [ "$SOURCEONLY" -eq 2 -a -f "$SRCDEST/$file" ]; then
			msg2 "$(gettext "Adding %s...")" "$file"
			ln -s "$SRCDEST/$file" "${srclinks}/${pkgbase}/"
		fi
	done

	local TAR_OPT
	case "$SRCEXT" in
		*tar.gz)  TAR_OPT="z" ;;
		*tar.bz2) TAR_OPT="j" ;;
		*tar.xz)  TAR_OPT="J" ;;
		*) warning "$(gettext "'%s' is not a valid archive extension.")" \
		"$SRCEXT" ;;
	esac

	local pkg_file="$PKGDEST/${pkgbase}-${pkgver}-${pkgrel}${SRCEXT}"

	# tar it up
	msg2 "$(gettext "Compressing source package...")"
	cd "${srclinks}"
	if ! bsdtar -c${TAR_OPT}Lf "$pkg_file" ${pkgbase}; then
		error "$(gettext "Failed to create source package file.")"
		exit 1 # TODO: error code
	fi
	cd "${startdir}"
	rm -rf "${srclinks}"
}

install_package() {
	[ "$INSTALL" -eq 0 ] && return

	if [ "$SPLITPKG" -eq 0 ]; then
		msg "$(gettext "Installing package ${pkgname} with pacman -U...")"
	else
		msg "$(gettext "Installing ${pkgbase} package group with pacman -U...")"
	fi

	local pkglist
	for pkg in ${pkgname[@]}; do
		pkglist="${pkglist} $PKGDEST/${pkg}-${pkgver}-${pkgrel}-${CARCH}${PKGEXT}"
	done

	local ret=0
	if [ "$ASROOT" -eq 0 ]; then
		sudo pacman $PACMAN_OPTS -U ${pkglist} || ret=$?
	else
		pacman $PACMAN_OPTS -U ${pkglist} || ret=$?
	fi

	if [ $ret -ne 0 ]; then
		warning "$(gettext "Failed to install built package(s).")"
		return 0
	fi
}

check_sanity() {
	# check for no-no's in the build script
	if [ -z "$pkgname" ]; then
		error "$(gettext "%s is not allowed to be empty.")" "pkgname"
		return 1
	fi
	if [ -z "$pkgver" ]; then
		error "$(gettext "%s is not allowed to be empty.")" "pkgver"
		return 1
	fi
	if [ -z "$pkgrel" ]; then
		error "$(gettext "%s is not allowed to be empty.")" "pkgrel"
		return 1
	fi
	if [ "${pkgname:0:1}" == "-" ]; then
		error "$(gettext "%s is not allowed to start with a hyphen.")" "pkgname"
		return 1
	fi
	if [ "$pkgver" != "${pkgver//-/}" ]; then
		error "$(gettext "%s is not allowed to contain hyphens.")" "pkgver"
		return 1
	fi
	if [ "$pkgrel" != "${pkgrel//-/}" ]; then
		error "$(gettext "%s is not allowed to contain hyphens.")" "pkgrel"
		return 1
	fi

	if [ "$arch" = 'any' ]; then
		CARCH='any'
	fi
	if ! in_array $CARCH ${arch[@]}; then
		if [ "$IGNOREARCH" -eq 0 ]; then
			error "$(gettext "%s is not available for the '%s' architecture.")" "$pkgbase" "$CARCH"
			plain "$(gettext "Note that many packages may need a line added to their %s")" "$BUILDSCRIPT"
			plain "$(gettext "such as arch=('%s').")" "$CARCH"
			return 1
		fi
	fi

	local provide
	for provide in ${provides[@]}; do
		if [ $provide != ${provide//</} -o $provide != ${provide//>/} ]; then
			error "$(gettext "Provides array cannot contain comparison (< or >) operators.")"
			return 1
		fi
	done

	if [ "$install" -a ! -f "$install" ]; then
		error "$(gettext "Install scriptlet (%s) does not exist.")" "$install"
		return 1
	fi

	local valid_options=1
	local opt known kopt
	for opt in ${options[@]}; do
		known=0
		# check if option matches a known option or its inverse
		for kopt in ${packaging_options[@]} ${other_options[@]}; do
			if [ "${opt}" = "${kopt}" -o "${opt}" = "!${kopt}" ]; then
				known=1
			fi
		done
		if [ $known -eq 0 ]; then
			error "$(gettext "options array contains unknown option '%s'")" "$opt"
			valid_options=0
		fi
	done
	if [ $valid_options -eq 0 ]; then
		return 1
	fi

	if [ "${#pkgname[@]}" -gt "1" ]; then
		for pkg in ${pkgname[@]}; do
			if [ "$(type -t package_${pkg})" != "function" ]; then
				error "$(gettext "missing package function for split package '%s'")" "$pkg"
				return 1
			fi
		done
	fi

	return 0
}

devel_check() {
	newpkgver=""

	# Do not update pkgver if --holdver is set, when building a source package,
	# when reading PKGBUILD from pipe (-f), or if we cannot write to the file (-w)
	if [ "$HOLDVER" -eq 1 -o "$SOURCEONLY" -ne 0 -o ! -f "$BUILDFILE" \
	                      -o ! -w "$BUILDFILE" ]; then
		return
	fi

	if [ -z "$FORCE_VER" ]; then
		# Check if this is a svn/cvs/etc PKGBUILD; set $newpkgver if so.
		# This will only be used on the first call to makepkg; subsequent
		# calls to makepkg via fakeroot will explicitly pass the version
		# number to avoid having to determine the version number twice.
		# Also do a brief check to make sure we have the VCS tool available.
		oldpkgver=$pkgver
		if [ -n "${_darcstrunk}" -a -n "${_darcsmod}" ] ; then
			[ $(type -p darcs) ] || return 0
			msg "$(gettext "Determining latest darcs revision...")"
			newpkgver=$(date +%Y%m%d)
		elif [ -n "${_cvsroot}" -a -n "${_cvsmod}" ] ; then
			[ $(type -p cvs) ] || return 0
			msg "$(gettext "Determining latest cvs revision...")"
			newpkgver=$(date +%Y%m%d)
		elif [ -n "${_gitroot}" -a -n "${_gitname}" ] ; then
			[ $(type -p git) ] || return 0
			msg "$(gettext "Determining latest git revision...")"
			newpkgver=$(date +%Y%m%d)
		elif [ -n "${_svntrunk}" -a -n "${_svnmod}" ] ; then
			[ $(type -p svn) ] || return 0
			msg "$(gettext "Determining latest svn revision...")"
			newpkgver=$(LC_ALL=C svn info $_svntrunk | sed -n 's/^Last Changed Rev: \([0-9]*\)$/\1/p')
		elif [ -n "${_bzrtrunk}" -a -n "${_bzrmod}" ] ; then
			[ $(type -p bzr) ] || return 0
			msg "$(gettext "Determining latest bzr revision...")"
			newpkgver=$(bzr revno ${_bzrtrunk})
		elif [ -n "${_hgroot}" -a -n "${_hgrepo}" ] ; then
			[ $(type -p hg) ] || return 0
			msg "$(gettext "Determining latest hg revision...")"
			if [ -d ./src/$_hgrepo ] ; then
				cd ./src/$_hgrepo
				hg pull
				hg update
			else
				[[ ! -d ./src/ ]] && mkdir ./src/
				hg clone $_hgroot/$_hgrepo ./src/$_hgrepo
				cd ./src/$_hgrepo
			fi
			newpkgver=$(hg tip --template "{rev}")
			cd ../../
		fi

		if [ -n "$newpkgver" ]; then
			msg2 "$(gettext "Version found: %s")" "$newpkgver"
		fi

	else
		# Version number retrieved from fakeroot->makepkg argument
		newpkgver=$FORCE_VER
	fi
}

devel_update() {
	# This is lame, but if we're wanting to use an updated pkgver for
	# retrieving svn/cvs/etc sources, we'll update the PKGBUILD with
	# the new pkgver and then re-source it. This is the most robust
	# method for dealing with PKGBUILDs that use, e.g.:
	#
	#  pkgver=23
	#  ...
	#  _foo=pkgver
	#
	if [ -n "$newpkgver" ]; then
		if [ "$newpkgver" != "$pkgver" ]; then
			if [ -f "$BUILDFILE" -a -w "$BUILDFILE" ]; then
				sed -i  "s/^pkgver=[^ ]*/pkgver=$newpkgver/" "$BUILDFILE"
				sed -i  "s/^pkgrel=[^ ]*/pkgrel=1/" "$BUILDFILE"
				source "$BUILDFILE"
			fi
		fi
	fi
}

backup_package_variables() {
	for var in ${splitpkg_overrides[@]}; do
		indirect="${var}_backup"
		eval "${indirect}=(\${$var[@]})"
	done
}

restore_package_variables() {
	for var in ${splitpkg_overrides[@]}; do
		indirect="${var}_backup"
		if [ -n "${!indirect}" ]; then
			eval "${var}=(\${$indirect[@]})"
		else
			unset ${var}
		fi
	done

	# pkgdesc gets restored as an array - convert back to a string
	local pkgdesc_backup="${pkgdesc[@]}"
	unset pkgdesc
	pkgdesc=${pkgdesc_backup}
}

# getopt like parser
parse_options() {
	local short_options=$1; shift;
	local long_options=$1; shift;
	local ret=0;
	local unused_options=""

	while [ -n "$1" ]; do
		if [ ${1:0:2} = '--' ]; then
			if [ -n "${1:2}" ]; then
				local match=""
				for i in ${long_options//,/ }; do
					if [ ${1:2} = ${i//:} ]; then
						match=$i
						break
					fi
				done
				if [ -n "$match" ]; then
					if [ ${1:2} = $match ]; then
						printf ' %s' "$1"
					else
						if [ -n "$2" ]; then
							printf ' %s' "$1"
							shift
							printf " '%s'" "$1"
						else
							echo "makepkg: option '$1' $(gettext "requires an argument")" >&2
							ret=1
						fi
					fi
				else
					echo "makepkg: $(gettext "unrecognized option") '$1'" >&2
					ret=1
				fi
			else
				shift
				break
			fi
		elif [ ${1:0:1} = '-' ]; then
			for ((i=1; i<${#1}; i++)); do
				if [[ "$short_options" =~ "${1:i:1}" ]]; then
					if [[ "$short_options" =~ "${1:i:1}:" ]]; then
						if [ -n "${1:$i+1}" ]; then
							printf ' -%s' "${1:i:1}"
							printf " '%s'" "${1:$i+1}"
						else
							if [ -n "$2" ]; then
								printf ' -%s' "${1:i:1}"
								shift
								printf " '%s'" "${1}"
							else
								echo "makepkg: option $(gettext "requires an argument") -- '${1:i:1}'" >&2
								ret=1
							fi
						fi
						break
					else
						printf ' -%s' "${1:i:1}"
					fi
				else
					echo "makepkg: $(gettext "invalid option") -- '${1:i:1}'" >&2
					ret=1
				fi
			done
		else
			unused_options="${unused_options} '$1'"
		fi
		shift
	done

	printf " --"
	if [ -n "$unused_options" ]; then
		for i in ${unused_options[@]}; do
			printf ' %s' "$i"
		done
	fi
	if [ -n "$1" ]; then
		while [ -n "$1" ]; do
			printf " '%s'" "${1}"
			shift
		done
	fi
	printf "\n"

	return $ret
}

usage() {
	printf "makepkg (pacman) %s\n" "$myver"
	echo
	printf "$(gettext "Usage: %s [options]")\n" "$0"
	echo
	echo "$(gettext "Options:")"
	printf "$(gettext "  -A, --ignorearch Ignore incomplete arch field in %s")\n" "$BUILDSCRIPT"
	echo "$(gettext "  -c, --clean      Clean up work files after build")"
	echo "$(gettext "  -C, --cleancache Clean up source files from the cache")"
	printf "$(gettext "  --config <config> Use an alternate config file (instead of '%s')")\n" "$confdir/makepkg.conf"
	echo "$(gettext "  -d, --nodeps     Skip all dependency checks")"
	echo "$(gettext "  -e, --noextract  Do not extract source files (use existing src/ dir)")"
	echo "$(gettext "  -f, --force      Overwrite existing package")"
	echo "$(gettext "  -g, --geninteg   Generate integrity checks for source files")"
	echo "$(gettext "  -h, --help       This help")"
	echo "$(gettext "  -i, --install    Install package after successful build")"
	echo "$(gettext "  -L, --log        Log package build process")"
	echo "$(gettext "  -m, --nocolor    Disable colorized output messages")"
	echo "$(gettext "  -o, --nobuild    Download and extract files only")"
	printf "$(gettext "  -p <buildscript> Use an alternate build script (instead of '%s')")\n" "$BUILDSCRIPT"
	echo "$(gettext "  -r, --rmdeps     Remove installed dependencies after a successful build")"
	# fix flyspray feature request #2978
	echo "$(gettext "  -R, --repackage  Repackage contents of the package without rebuilding")"
	echo "$(gettext "  -s, --syncdeps   Install missing dependencies with pacman")"
	echo "$(gettext "  -t, --splitdbg   Put debugging symbols into their own package")"
	echo "$(gettext "  -u, --splithdr   Put development headers into their own package")"
	echo "$(gettext "      --allsource  Generate a source-only tarball including downloaded sources")"
	echo "$(gettext "      --asroot     Allow makepkg to run as root user")"
	echo "$(gettext "      --holdver    Prevent automatic version bumping for development PKGBUILDs")"
	echo "$(gettext "      --source     Generate a source-only tarball without downloaded sources")"
	echo
	echo "$(gettext "These options can be passed to pacman:")"
	echo
	echo "$(gettext "      --noconfirm      Do not ask for confirmation when resolving dependencies")"
	echo "$(gettext "      --noprogressbar  Do not show a progress bar when downloading files")"
	echo
	printf "$(gettext "If -p is not specified, makepkg will look for '%s'")\n" "$BUILDSCRIPT"
	echo
}

version() {
	printf "makepkg (pacman) %s\n" "$myver"
	printf "$(gettext "\
Copyright (c) 2006-2009 Pacman Development Team <pacman-dev@archlinux.org>.\n\
Copyright (C) 2002-2006 Judd Vinet <jvinet@zeroflux.org>.\n\n\
This is free software; see the source for copying conditions.\n\
There is NO WARRANTY, to the extent permitted by law.\n")"
}

# PROGRAM START

# determine whether we have gettext; make it a no-op if we do not
if [ ! $(type -t gettext) ]; then
	gettext() {
		echo "$@"
	}
fi

ARGLIST=$@

# Parse Command Line Options.
OPT_SHORT="AbcCdefFghiLmop:rRstuV"
OPT_LONG="allsource,asroot,ignorearch,builddeps,clean,cleancache,nodeps"
OPT_LONG="$OPT_LONG,noextract,force,forcever:,geninteg,help,holdver"
OPT_LONG="$OPT_LONG,install,log,nocolor,nobuild,rmdeps,repackage,source"
OPT_LONG="$OPT_LONG,syncdeps,splitdbg,splithdr,version,config:"
# Pacman Options
OPT_LONG="$OPT_LONG,noconfirm,noprogressbar"
OPT_TEMP="$(parse_options $OPT_SHORT $OPT_LONG "$@" || echo 'PARSE_OPTIONS FAILED')"
if echo "$OPT_TEMP" | grep -q 'PARSE_OPTIONS FAILED'; then
	# This is a small hack to stop the script bailing with 'set -e'
	echo; usage; exit 1 # E_INVALID_OPTION;
fi
eval set -- "$OPT_TEMP"
unset OPT_SHORT OPT_LONG OPT_TEMP

while true; do
	case "$1" in
		# Pacman Options
		--noconfirm)      PACMAN_OPTS="$PACMAN_OPTS --noconfirm" ;;
		--noprogressbar)  PACMAN_OPTS="$PACMAN_OPTS --noprogressbar" ;;

		# Makepkg Options
		--allsource)      SOURCEONLY=2 ;;
		--asroot)         ASROOT=1 ;;
		-A|--ignorearch)  IGNOREARCH=1 ;;
		-c|--clean)       CLEANUP=1 ;;
		-C|--cleancache)  CLEANCACHE=1 ;;
		--config)         shift; MAKEPKG_CONF=$1 ;;
		-d|--nodeps)      NODEPS=1 ;;
		-e|--noextract)   NOEXTRACT=1 ;;
		-f|--force)       FORCE=1 ;;
		#hidden opt used by fakeroot call for svn/cvs/etc PKGBUILDs to set pkgver
		--forcever)       shift; FORCE_VER=$1;;
		-F)               INFAKEROOT=1 ;;
		-g|--geninteg)    GENINTEG=1 ;;
		--holdver)        HOLDVER=1 ;;
		-i|--install)     INSTALL=1 ;;
		-L|--log)         LOGGING=1 ;;
		-m|--nocolor)     USE_COLOR='n' ;;
		-o|--nobuild)     NOBUILD=1 ;;
		-p)               shift; BUILDFILE=$1 ;;
		-r|--rmdeps)      RMDEPS=1 ;;
		-R|--repackage)   REPKG=1 ;;
		--source)         SOURCEONLY=1 ;;
		-s|--syncdeps)    DEP_BIN=1 ;;
		-t|--splitdbg)    SPLIT_DBG=1 ;;
		-u|--splithdr)    SPLIT_HDR=1 ;;

		-h|--help)        usage; exit 0 ;; # E_OK
		-V|--version)     version; exit 0 ;; # E_OK

		--)               OPT_IND=0; shift; break;;
		*)                usage; exit 1 ;; # E_INVALID_OPTION
	esac
	shift
done

#preserve environment variables
_PKGDEST=${PKGDEST}
_SRCDEST=${SRCDEST}

# default config is makepkg.conf
MAKEPKG_CONF=${MAKEPKG_CONF:-$confdir/${current_repo}-${ARCH}-makepkg.conf}

# Source the config file; fail if it is not found
if [ -r "$MAKEPKG_CONF" ]; then
	source "$MAKEPKG_CONF"
else
	error "$(gettext "%s not found.")" "$MAKEPKG_CONF"
	plain "$(gettext "Aborting...")"
	exit 1 # $E_CONFIG_ERROR
fi

# Source user-specific makepkg.conf overrides
# (we dont need that)
# if [ -r ~/.makepkg.conf ]; then
# 	source ~/.makepkg.conf
# fi

# check if messages are to be printed using color
if [ -t 2 -a ! "$USE_COLOR" = "n" -a "$(check_buildenv color)" = "y" ]; then
	COLORMSG=1
fi

# override settings with an environment variable for batch processing
PKGDEST=${_PKGDEST:-$PKGDEST}
PKGDEST=${PKGDEST:-$startdir} #default to $startdir if undefined
SRCDEST=${_SRCDEST:-$SRCDEST}
SRCDEST=${SRCDEST:-$startdir} #default to $startdir if undefined


if [ "$HOLDVER" -eq 1 -a -n "$FORCE_VER" ]; then
	# The '\\0' is here to prevent gettext from thinking --holdver is an option
	error "$(gettext "\\0--holdver and --forcever cannot both be specified" )"
	exit 1
fi

if [ "$CLEANCACHE" -eq 1 ]; then
	#fix flyspray feature request #5223
	if [ -n "$SRCDEST" -a "$SRCDEST" != "$startdir" ]; then
		msg "$(gettext "Cleaning up ALL files from %s.")" "$SRCDEST"
		echo -n "$(gettext "    Are you sure you wish to do this? ")"
		echo -n "$(gettext "[Y/n]")"
		read answer
		answer=$(echo $answer | tr '[:lower:]' '[:upper:]')
		if [ "$answer" = "$(gettext "YES")" -o "$answer" = "$(gettext "Y")" ]; then
			rm "$SRCDEST"/*
			if [ $? -ne 0 ]; then
				error "$(gettext "Problem removing files; you may not have correct permissions in %s")" "$SRCDEST"
				exit 1
			else
				# removal worked
				msg "$(gettext "Source cache cleaned.")"
				exit 0
			fi
		else
			# answer = no
			msg "$(gettext "No files have been removed.")"
			exit 0
		fi
	else
		# $SRCDEST is $startdir, two possibilities
		error "$(gettext "Source destination must be defined in %s.")" "$MAKEPKG_CONF"
		plain "$(gettext "In addition, please run makepkg -C outside of your cache directory.")"
		exit 1
	fi
fi

if [ "$INFAKEROOT" -eq 0 ]; then
	if [ $EUID -eq 0 -a "$ASROOT" -eq 0 ]; then
		# Warn those who like to live dangerously.
		error "$(gettext "Running makepkg as root is a BAD idea and can cause")"
		plain "$(gettext "permanent, catastrophic damage to your system. If you")"
		plain "$(gettext "wish to run as root, please use the --asroot option.")"
		exit 1 # $E_USER_ABORT
	elif [ $EUID -gt 0 -a "$ASROOT" -eq 1 ]; then
		# Warn those who try to use the --asroot option when they are not root
		error "$(gettext "The --asroot option is meant for the root user only.")"
		plain "$(gettext "Please rerun makepkg without the --asroot flag.")"
		exit 1 # $E_USER_ABORT
	elif [ "$(check_buildenv fakeroot)" = "y" -a $EUID -gt 0 ]; then
		if [ ! $(type -p fakeroot) ]; then
			error "$(gettext "Fakeroot must be installed if using the 'fakeroot' option")"
			plain "$(gettext "in the BUILDENV array in %s.")" "$MAKEPKG_CONF"
			exit 1
		fi
	elif [ $EUID -gt 0 ]; then
		warning "$(gettext "Running makepkg as an unprivileged user will result in non-root")"
		plain "$(gettext "ownership of the packaged files. Try using the fakeroot environment by")"
		plain "$(gettext "placing 'fakeroot' in the BUILDENV array in %s.")" "$MAKEPKG_CONF"
		sleep 1
	fi
else
	if [ -z "$FAKEROOTKEY" ]; then
		error "$(gettext "Do not use the '-F' option. This option is only for use by makepkg.")"
		exit 1 # TODO: error code
	fi
fi

# check for sudo if we will need it during makepkg execution
if [ "$ASROOT" -eq 0 \
     -a \( "$DEP_BIN" -eq 1 -o "$RMDEPS" -eq 1 -o "$INSTALL" -eq 1 \) ]; then
	if [ ! "$(type -p sudo)" ]; then
		error "$(gettext "Cannot find the sudo binary! Is sudo installed?")"
		plain "$(gettext "Missing dependencies cannot be installed or removed as a normal user")"
		plain "$(gettext "without sudo; install and configure sudo to auto-resolve dependencies.")"
		exit 1
	fi
fi

unset pkgname pkgbase pkgver pkgrel pkgdesc url license groups provides
unset md5sums replaces depends conflicts backup source install build
unset makedepends optdepends options noextract

BUILDFILE=${BUILDFILE:-$BUILDSCRIPT}
if [ ! -f "$BUILDFILE" ]; then
	if [ -t 0 ]; then
		error "$(gettext "%s does not exist.")" "$BUILDFILE"
		exit 1
	else
		# PKGBUILD passed through a pipe
		BUILDFILE=/dev/stdin
		source "$BUILDFILE"
	fi
else
	crlftest=$(file "$BUILDFILE" | grep -F 'CRLF' || true)
	if [ -n "$crlftest" ]; then
		error "$(gettext "%s contains CRLF characters and cannot be sourced.")" "$BUILDFILE"
		exit 1
	fi

	if [ "${BUILDFILE:0:1}" != "/" ]; then
		BUILDFILE="$startdir/$BUILDFILE"
	fi
	source "$BUILDFILE"
fi

if [ "$GENINTEG" -eq 1 ]; then
	mkdir -p "$srcdir"
	cd "$srcdir"
	download_sources
	generate_checksums
	exit 0 # $E_OK
fi

if [ "$(type -t package)" = "function" ]; then
	PKGFUNC=1
fi

# check the PKGBUILD for some basic requirements
check_sanity || exit 1

# We need to run devel_update regardless of whether we are in the fakeroot
# build process so that if the user runs makepkg --forcever manually, we
# 1) output the correct pkgver, and 2) use the correct filename when
# checking if the package file already exists - fixes FS #9194
devel_check
devel_update

if [ "${#pkgname[@]}" -gt "1" ]; then
	SPLITPKG=1
fi

pkgbase=${pkgbase:-${pkgname[0]}}

if [ "$SPLITPKG" -eq 0 ]; then
	if [ -f "$PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}${PKGEXT}" \
			-a "$FORCE" -eq 0 -a "$SOURCEONLY" -eq 0 -a "$NOBUILD" -eq 0 ]; then
		if [ "$INSTALL" -eq 1 ]; then
			warning "$(gettext "A package has already been built, installing existing package...")"
			install_package
			exit $?
		else
			error "$(gettext "A package has already been built. (use -f to overwrite)")"
			exit 1
		fi
	fi
else
	allpkgbuilt=1
	somepkgbuilt=0
	for pkg in ${pkgname[@]}; do
		if [ -f "$PKGDEST/${pkg}-${pkgver}-${pkgrel}-${CARCH}${PKGEXT}" ]; then
			somepkgbuilt=1
		else
			allpkgbuilt=0
		fi
	done
	if [ "$FORCE" -eq 0 -a "$SOURCEONLY" -eq 0 -a "$NOBUILD" -eq 0 ]; then
		if [ "$allpkgbuilt" -eq 1 ]; then
			if [ "$INSTALL" -eq 1 ]; then
				warning "$(gettext "The package group has already been built, installing existing packages...")"
				install_package
				exit $?
			else
				error "$(gettext "The package group has already been built. (use -f to overwrite)")"
				exit 1
			fi
		fi
		if [ "$somepkgbuilt" -eq 1 ]; then
			error "$(gettext "Part of the package group has already been built. (use -f to overwrite)")"
			exit 1
		fi
	fi
	unset allpkgbuilt somepkgbuilt
fi

# Run the bare minimum in fakeroot
if [ "$INFAKEROOT" -eq 1 ]; then
	if [ "$SPLITPKG" -eq 0 ]; then
		if [ "$PKGFUNC" -eq 0 ]; then
			if [ "$REPKG" -eq 0 ]; then
				run_build
				if [ "$(check_option splitdbg)" = "y" ] || [ "$(check_option splithdr)" = "y" ] || [ "$SPLIT_DBG" = "1" ] || [ "$SPLIT_HDR" = "1" ]; then
					tidy_install
				fi
			fi
		else
			run_package
			tidy_install
		fi
		if [ "$(check_option splitdbg)" = "y" ] || [ "$(check_option splithdr)" = "y" ] || [ "$SPLIT_DBG" = "1" ] || [ "$SPLIT_HDR" = "1" ]; then
			create_package
			# second check, if there are any files
			check_dbg_files=`find $dbgdir/ -name "*.debug"`
			if [ -z "$check_dbg_files" ]; then
				msg "$(gettext "No .debug files found, skipping creation of the debug pkg...")"
			else
				create_debug_package
			fi
			
			# second check, if there are any files
			check_hdr_files=`find $hdrdir/ -name "include"`
			if [ -z "$check_hdr_files" ]; then
				msg "$(gettext "Skipping creation of the devel pkg...")"
			else
				create_header_package
			fi
		else
			create_package
		fi
	else
		for pkg in ${pkgname[@]}; do
			pkgdir="$pkgdir/pkg_${pkg}"
			mkdir -p "$pkgdir"
			dbgdir="$startdir/dbg/dbg_${pkg}"
			[ ! -d "$dbgdir" ] && mkdir -p "$dbgdir"
			hdrdir="$startdir/hdr/hdr_${pkg}"
			[ ! -d "$hdrdir" ] && mkdir -p "$hdrdir"
			backup_package_variables
			run_package $pkg
			tidy_install

			if [ "$(check_option splitdbg)" = "y" ] || [ "$(check_option splithdr)" = "y" ] || [ "$SPLIT_DBG" = "1" ] || [ "$SPLIT_HDR" = "1" ]; then
				create_package $pkg
				# second check, if there are any files
				check_dbg_files=`find $dbgdir/ -name "*.debug"`
				if [ -z "$check_dbg_files" ]; then
					msg "$(gettext "No .debug files found, skipping creation of the debug pkg...")"
				else
					create_debug_package $pkg
				fi
				# third check, headers
				check_hdr_files=`find $hdrdir/ -name "include"`
				if [ -z "$check_hdr_files" ]; then
					msg "$(gettext "Skipping creation of the devel pkg...")"
				else
					create_header_package $pkg
				fi

			else
				create_package $pkg
			fi

			restore_package_variables
			pkgdir="${pkgdir%/*}"
		done
	fi

	msg "$(gettext "Leaving fakeroot environment.")"
	exit 0 # $E_OK
fi

msg "$(gettext "Making package: %s")" "$pkgbase $pkgver-$pkgrel $CARCH ($(date))"

# if we are creating a source-only package, go no further
if [ "$SOURCEONLY" -ne 0 ]; then
	if [ -f "$PKGDEST/${pkgbase}-${pkgver}-${pkgrel}${SRCEXT}" \
	     -a "$FORCE" -eq 0 ]; then
		error "$(gettext "A package has already been built. (use -f to overwrite)")"
		exit 1
	fi
	create_srcpackage
	msg "$(gettext "Source package created: %s")" "$pkgbase ($(date))"
	exit 0
fi

# fix flyspray bug #5973
if [ "$NODEPS" -eq 1 -o "$NOBUILD" -eq 1 -o "$REPKG" -eq 1 ]; then
	# no warning message needed for nobuild, repkg
	if [ "$NODEPS" -eq 1 ]; then
		warning "$(gettext "Skipping dependency checks.")"
	fi
elif [ $(type -p pacman) ]; then
	unset pkgdeps # Set by resolve_deps() and used by remove_deps()
	deperr=0

	msg "$(gettext "Checking Runtime Dependencies...")"
	resolve_deps ${depends[@]} || deperr=1

	msg "$(gettext "Checking Buildtime Dependencies...")"
	resolve_deps ${makedepends[@]} || deperr=1

	if [ $deperr -eq 1 ]; then
		error "$(gettext "Could not resolve all dependencies.")"
		exit 1
	fi
else
	warning "$(gettext "pacman was not found in PATH; skipping dependency checks.")"
fi

# ensure we have a sane umask set
umask 0022

# get back to our src directory so we can begin with sources
mkdir -p "$srcdir"
mkdir -p "$dbgdir"
mkdir -p "$hdrdir"
cd "$srcdir"

if [ "$NOEXTRACT" -eq 1 ]; then
	warning "$(gettext "Skipping source retrieval        -- using existing src/ tree")"
	warning "$(gettext "Skipping source integrity checks -- using existing src/ tree")"
	warning "$(gettext "Skipping source extraction       -- using existing src/ tree")"

	if [ "$NOEXTRACT" -eq 1 -a -z "$(ls "$srcdir" 2>/dev/null)" ]; then
		error "$(gettext "The source directory is empty, there is nothing to build!")"
		plain "$(gettext "Aborting...")"
		exit 1
	fi
elif [ "$REPKG" -eq 1 ]; then
	if [ "$PKGFUNC" -eq 0 -a "$SPLITPKG" -eq 0 \
	     -a \( ! -d "$pkgdir" -o -z "$(ls "$pkgdir" 2>/dev/null)" \) ]; then
		error "$(gettext "The package directory is empty, there is nothing to repackage!")"
		plain "$(gettext "Aborting...")"
		exit 1
	fi
else
	download_sources
	check_checksums
	extract_sources
fi

if [ "$NOBUILD" -eq 1 ]; then
	msg "$(gettext "Sources are ready.")"
	exit 0 #E_OK
else
	# check for existing pkg directory; don't remove if we are repackaging
	if [ -d "$pkgdir" \
	     -a \( "$REPKG" -eq 0 -o "$PKGFUNC" -eq 1 -o "$SPLITPKG" -eq 1 \) ]; then
		msg "$(gettext "Removing existing pkg/ directory...")"
		rm -rf "$pkgdir"
	fi
	mkdir -p "$pkgdir"
	cd "$startdir"

	# if we are root or if fakeroot is not enabled, then we don't use it
	if [ "$(check_buildenv fakeroot)" != "y" -o $EUID -eq 0 ]; then
		if [ "$REPKG" -eq 0 ]; then
			devel_update
			run_build
		fi
		if [ "$SPLITPKG" -eq 0 ]; then
			if [ "$PKGFUNC" -eq 1 ]; then
				run_package
				tidy_install
			elif [ "$REPKG" -eq 0 ]; then
				tidy_install
			fi
			
			if [ "$(check_option splitdbg)" = "y" ] || [ "$(check_option splithdr)" = "y" ] || [ "$SPLIT_DBG" = "1" ] || [ "$SPLIT_HDR" = "1" ]; then
				create_package
				# second check, if there are any files
				check_dbg_files=`find $dbgdir/ -name "*.debug"`
				if [ -z "$check_dbg_files" ]; then
					msg "$(gettext "No .debug files found, skipping creation of debug packages...")"
				else
					create_debug_package
				fi
				# second check, if there are any files
				check_hdr_files=`find $hdrdir/ -name "include"`
				if [ -z "$check_hdr_files" ]; then
					msg "$(gettext "Skipping creation of the devel pkg...")"
				else
					create_header_package
				fi
			else
				create_package
			fi

		else
			for pkg in ${pkgname[@]}; do
				pkgdir="$pkgdir/pkg_$pkg"
				mkdir -p "$pkgdir"
				dbgdir="$startdir/dbg/dbg_${pkg}"
				[ ! -d "$dbgdir" ] && mkdir -p "$dbgdir"
				hdrdir="$startdir/hdr/hdr_${pkg}"
				[ ! -d "$hdrdir" ] && mkdir -p "$hdrdir"
				backup_package_variables
				run_package $pkg
				tidy_install

				if [ "$(check_option splitdbg)" = "y" ] || [ "$(check_option splithdr)" = "y" ] || [ "$SPLIT_DBG" = "1" ] || [ "$SPLIT_HDR" = "1" ]; then
					create_package $pkg
					# second check, if there are any files
					check_dbg_files=`find $dbgdir/ -name "*.debug"`
					if [ -z "$check_dbg_files" ]; then
						msg "$(gettext "No .debug files found, skipping creation of debug packages...")"
					else
						create_debug_package $pkg
					fi
					check_hdr_files=`find $hdrdir/ -name "include"`
					if [ -z "$check_hdr_files" ]; then
						msg "$(gettext "Skipping creation of the devel pkg...")"
					else
						create_header_package $pkg
					fi
				else
					create_package $pkg
				fi

				restore_package_variables
				pkgdir="${pkgdir%/*}"
			done
		fi
	else
		if [ "$REPKG" -eq 0 -a \( "$PKGFUNC" -eq 1 -o "$SPLITPKG" -eq 1 \) ]; then
			devel_update
			run_build
			cd "$startdir"
		fi

		msg "$(gettext "Entering fakeroot environment...")"

		if [ -n "$newpkgver" ]; then
			fakeroot -- $0 --forcever $newpkgver -F $ARGLIST || exit $?
		else
			fakeroot -- $0 -F $ARGLIST || exit $?
		fi
	fi
fi

msg "$(gettext "Finished making: %s")" "$pkgbase $pkgver-$pkgrel $CARCH ($(date))"

install_package

exit 0 #E_OK

# vim: set ts=2 sw=2 noet:
